# Rotation Model

The Rotation model in Flow360 handles rotating components in two fundamentally different ways: through physical mesh rotation in unsteady simulations or through reference frame approaches (MRF/SRF) in steady simulations.

---

## üìù **Rotation Configuration**

*The Rotation model provides different approaches to simulate rotating components:*

1. **Unsteady Simulation with Physical Mesh Rotation**: The mesh actually rotates over time, capturing time-dependent effects such as blade passing. This requires time-accurate simulation.

2. **Steady Simulation with Multiple Reference Frame (MRF)**: The mesh remains fixed while rotational forces are added to the momentum equations. This "freezes" the rotor in one position while approximating rotational effects, allowing for steady-state solutions.

3. **Steady Simulation with Single Reference Frame (SRF)**: The entire simulation domain rotates around an axis, which is useful for simulating maneuvers like pitch, roll, or yaw.

---

### üìã **Available Parameters**

| **Parameter** | **Description** | **Unit** |
|---------------|-----------------|----------|
| `Entities` | Volumes that rotate (must have center and axis defined) | |
| `Spec` | Specification of rotation (one of the following options): | |
| `- Angular Velocity` | Constant rotation rate specification (can be used in both steady MRF/SRF and unsteady) | angular velocity (e.g., rad/s, rpm) |
| `- Angle Expression` | Time-dependent rotation angle formula (unsteady simulations only) | expression returning radians |
| `- From User Defined Dynamics` | Rotation controlled by user dynamics model (unsteady simulations only) | |
| `Parent Volume` | Optional parent rotating entity for nested rotations | |
| `Rotating Reference Frame Model` | Flag for using MRF approach (must be True for steady MRF simulations) | |
| `Reference Frame Type` | Specifies MRF or SRF approach for steady simulations | |

---

### üîç **Detailed Descriptions**

#### `Entities`

*The entity list for the Rotation model. The entity should be Cylinder or GenericVolume type.*

- **Default:** None (required parameter)
- **Example:** `[volume_mesh["rotating_zone"]]`
- **Notes:** 
  - Each entity must have `center` and `axis` properties defined
  - The center defines the point through which the rotation axis passes
  - The axis defines the direction of the rotation axis

#### `Spec`

*The angular velocity or rotation angle as a function of time.*

- **Default:** None (required parameter)
- **Options:**
  - **Angular Velocity**: Constant rotation rate
  - **Angle Expression**: Time-dependent rotation angle formula
  - **From User Defined Dynamics**: Rotation controlled by user dynamics
- **Notes:** The appropriate option depends on both your simulation type (steady or unsteady) and your modeling requirements

##### Angular Velocity

*Defines a constant angular velocity for the rotating domain.*

- **Example:** `AngularVelocity(812.31 * u.rpm)` or `AngularVelocity(85.06 * u.rad / u.s)`
- **Notes:** 
  - Can be specified in various angular velocity units such as rad/s or rpm
  - Used in steady simulations with MRF/SRF to specify the rotational speed of the reference frame
  - Used in unsteady simulations to specify a constant physical rotation rate

##### Angle Expression

*Defines the rotation angle as a function of time.*

- **Example:** `AngleExpression("0.1*sin(t)")`
- **Notes:** 
  - The result of the expression is assumed to be in radians
  - Allows for periodic or complex rotation patterns
  - Variable 't' represents time
  - Can only be used in unsteady/time-accurate simulations with physical mesh rotation
  - Incompatible with steady-state MRF/SRF approaches

##### From User Defined Dynamics

*Sets the rotation to be controlled by user defined dynamics.*

- **Example:** `FromUserDefinedDynamics()`
- **Notes:** 
  - Requires setting up a UserDefinedDynamics model in the simulation parameters
  - Can only be used in unsteady/time-accurate simulations with physical mesh rotation
  - Incompatible with steady-state MRF/SRF approaches

#### `Parent Volume`

*The parent rotating entity in a nested rotation case.*

- **Default:** None
- **Example:** `volume_mesh["outer_rotating_zone"]`
- **Notes:**
  - Used for complex systems with multiple rotating components
  - The entity should be Cylinder or GenericVolume type
  - Child rotation is relative to the parent rotation
  - Works in both steady MRF/SRF and unsteady approaches

#### `Rotating Reference Frame Model`

*Flag to specify whether the non-inertial reference frame model is to be used for the rotation model.*

- **Default:** None
- **Example:** `True`
- **Notes:** 
  - Must be set to True for steady-state simulations using MRF approach
  - Controls whether rotation is handled via reference frame transformation (MRF) or physical mesh rotation

#### `Multiple Reference Frame (MRF)`

*An efficient approach for simulating rotating machinery in steady-state.*

- **Description:** The MRF method offers significant computational advantages when contrasted with unsteady sliding interfaces, as the flow field can be solved using the steady-state flow solver
- **How it works:**
  - Both the mesh and the rotor remain stationary in space
  - The impact of rotation is incorporated by adding centrifugal and Coriolis source terms to the Navier-Stokes equations within the rotating volume zones
- **Best for:** Steady simulations of rotating components such as rotors, turbomachinery, and wind turbines
- **Important limitations:**
  - The formulation is **ONLY** exact when the flow field is rotationally invariant on the interface
  - Any variation in the circumferential direction can lead to non-physical behavior across the interface, such as discontinuous rotor wake
  - When pursuing high-fidelity results, MRF typically requires a larger sliding zone in the wake region than unsteady simulations

#### `Single Reference Frame (SRF)`

*An approach where the entire simulation domain rotates around an axis.*

- **Description:** Unlike MRF where both stationary and rotating volume zones coexist, in SRF the entire simulation domain rotates around a specified axis
- **Best for:** Steady simulations involving maneuvers (pitch/roll/yaw)
- **Boundary condition considerations:**
  - The "velocityType" parameter under "NoSlipWall" and "Freestream" boundary conditions offers two options:
    - "relative" (enforcing zero relative velocity)
    - "absolute" (enforcing zero absolute velocity)
  - For NoSlipWall, "relative" is used for rotating surfaces (e.g., blades of a rotor), whereas "absolute" is used for fixed surfaces (e.g., wind tunnel walls)

---

<details>
<summary><h3 style="display:inline-block"> üí° Tips</h3></summary>

#### For All Rotation Simulations
- Define rotation axis and center consistently with your coordinate system
- The axis vector does not need to be normalized; the direction is what matters
- For nested rotations, define the outermost rotation first, then the inner rotations

#### For Steady Simulations with MRF
- Set `Rotating Reference Frame Model = True`
- Use `Angular Velocity` for rotation specification
- Create clean interfaces between rotating and stationary zones
- Position interfaces in regions with primarily axial flow when possible
- Avoid placing interfaces in regions with strong radial flow gradients
- MRF is a good approximation for most propeller and turbomachinery applications
- Consider using a frozen rotor approach for initial convergence
- For high-fidelity results, you may need a larger sliding zone in the wake region

#### For Steady Simulations with SRF
- Use SRF when the entire domain needs to rotate (e.g., for simulating maneuvers)
- Be careful with boundary condition velocity types:
  - Use "relative" velocity type for rotating surfaces
  - Use "absolute" velocity type for fixed surfaces
- SRF is generally preferred over MRF for simulating maneuvers

#### For Unsteady Simulations with Physical Mesh Rotation
- Any of the three rotation specifications can be used (`Angular Velocity`, `Angle Expression` or `From User Defined Dynamics`)
- Ensure time step size is appropriate for the rotation rate
- For periodic motion using `Angle Expression`:
  - Keep the expression as simple as possible for better performance
  - Test with simple rotations first before implementing complex motion
- Ensure adequate mesh resolution in the rotating region

</details>

---

<details>
<summary><h3 style="display:inline-block"> ‚ùì Frequently Asked Questions</h3></summary>

- **What's the difference between MRF, SRF, and physical mesh rotation?**  
  > MRF (Multiple Reference Frame) is a steady-state approximation that adds rotational forces to specific volume zones while keeping the mesh fixed. SRF (Single Reference Frame) applies rotation to the entire simulation domain. Physical mesh rotation actually moves the mesh over time to simulate rotation and requires unsteady simulation. MRF and SRF are computationally efficient but cannot capture inherently unsteady effects like blade passing.

- **When should I use MRF vs. SRF?**  
  > Use MRF when you have distinct rotating and stationary regions, such as a propeller or turbomachinery stage with a fixed casing. Use SRF when the entire domain is rotating or when simulating maneuvers like pitch, roll, or yaw.

- **When should I use MRF/SRF vs. physical mesh rotation?**  
  > Use MRF/SRF for steady-state simulations where time-averaged performance is your primary interest (like overall thrust, torque, or efficiency of a propeller). Use physical mesh rotation for unsteady simulations where time-dependent phenomena are important (like blade-passing effects, acoustic analysis, or interaction with transient flow features).

- **When should I use Angular Velocity vs. Angle Expression?**  
  > Use Angular Velocity for constant rotation rate in either steady MRF/SRF simulations or unsteady physical rotation. Use Angle Expression only for unsteady simulations with physical mesh rotation when you need time-varying rotation rates, such as oscillating motion or accelerating/decelerating components.

- **How do nested rotations work?**  
  > Nested rotations allow one rotating component to be contained within another. The child component's rotation is relative to its parent. This is useful for modeling complex machinery like planetary gears or multi-stage turbomachinery. Works in both MRF/SRF and physical rotation approaches.

- **How do I determine the correct rotation direction?**  
  > The rotation follows the right-hand rule with respect to the axis vector. Point your right thumb along the axis vector, and your fingers curl in the direction of positive rotation.

- **Can I change rotation speed during a simulation?**  
  > In steady MRF/SRF simulations, no - the rotation rate is fixed. In unsteady simulations with physical mesh rotation, yes - by using Angle Expression with time dependency or by using User Defined Dynamics.

- **Do I need to place the rotation axis at the origin?**  
  > No, you can place the rotation axis anywhere by specifying the center and axis properties of the rotating entity.

- **What happens at interfaces between rotating and non-rotating zones in MRF?**  
  > Flow variables are transformed between reference frames at these interfaces. For best results, these interfaces should be positioned in regions with minimal flow variation. The MRF formulation is only exact when the flow field is rotationally invariant on the interface.

- **What's the difference in boundary condition handling between MRF and SRF?**  
  > In SRF, you need to specify whether boundary conditions use "relative" velocity (for rotating surfaces) or "absolute" velocity (for fixed surfaces). In MRF, this distinction is handled by which volume zone the boundary belongs to.

</details>

---

<details>
<summary><h3 style="display:inline-block"> üîÑ Common Applications</h3></summary>

### Propeller and Rotor Analysis
- **Steady MRF**: Performance prediction (thrust, torque, efficiency)
- **Steady SRF**: Simulations involving maneuvers (e.g., tilting rotors)
- **Unsteady Physical Rotation**: Blade-passing effects, acoustic analysis

### Turbomachinery
- **Steady MRF**: Performance metrics, stage analysis with multiple reference frames
- **Unsteady Physical Rotation**: Rotor-stator interactions, transient surge/stall studies

### Maneuvers and Vehicle Dynamics
- **Steady SRF**: Aircraft in steady roll, pitch, or yaw
- **Unsteady Physical Rotation**: Complex maneuver sequences with varying motion rates

### Mixing Equipment
- **Steady MRF**: Steady-state mixing patterns, time-averaged mixing efficiency
- **Unsteady Physical Rotation**: Transient mixing dynamics, time-dependent behavior

</details>

---

<details>
<summary><h3 style="display:inline-block"> üêç Python API Usage Example</h3></summary>

Below is an example of how to configure Rotation models using the Flow360 Python API:

```python
# Example (for reference only, not included in GUI documentation)

# Steady MRF rotation example
mrf_volume = volume_mesh["rotor"]
mrf_volume.center = (0, 0, 0) * u.m
mrf_volume.axis = (1, 0, 0)
mrf_rotation = fl.Rotation(
    name="steadyRotor",
    volumes=[mrf_volume],
    spec=fl.AngularVelocity(1200 * u.rpm),
    rotating_reference_frame_model=True  # Required for MRF
)

# Steady SRF example for aircraft in roll
srf_rotation = fl.Rotation(
    name="aircraftRoll",
    volumes=[volume_mesh["entire_domain"]],
    spec=fl.AngularVelocity(5 * u.deg / u.s),
    # SRF configuration would be specified here
)

# Unsteady physical rotation example
unsteady_volume = volume_mesh["propeller"]
unsteady_volume.center = (0, 0, 0) * u.m
unsteady_volume.axis = (1, 0, 0)

# Constant rotation rate
constant_rotation = fl.Rotation(
    name="constantSpeedPropeller",
    volumes=[unsteady_volume],
    spec=fl.AngularVelocity(1200 * u.rpm)
)

# Time-varying rotation angle
oscillating_rotation = fl.Rotation(
    name="oscillatingPropeller",
    volumes=[unsteady_volume],
    spec=fl.AngleExpression("0.5*sin(2*pi*t)")
)

# Nested rotation example
outer_volume = volume_mesh["outer"]
outer_volume.center = (-1, 0, 0) * u.m
outer_volume.axis = (0, 1, 0)
inner_volume = volume_mesh["inner"]
inner_volume.center = (0, 0, 0) * u.m
inner_volume.axis = (0, 1, 0)

outer_rotation = fl.Rotation(
    name="outerRotation",
    volumes=[outer_volume],
    spec=fl.AngularVelocity(10 * u.rad / u.s)
)

inner_rotation = fl.Rotation(
    name="innerRotation",
    volumes=[inner_volume],
    spec=fl.AngularVelocity(5 * u.rad / u.s),
    parent_volume=outer_volume  # Inner rotation nested in outer rotation
)
```
</details> 