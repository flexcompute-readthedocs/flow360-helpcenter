---
order: 01
---

# Upload Volume Mesh
1. Both CGNS and UGRID formats are supported.  
2. Both *.gz and *.bz2 compressions are supported.  
3. Tetrahedron, Pyramid, Prism and Hexahedron cells are allowed, Polyhedron cells are NOT supported.  
4. Here are [the best practices when manually preparing the mesh](https://docs.flexcompute.com/projects/flow360/en/latest/preprocessing/manualMeshing/manualMeshing.html).

## CGNS 
1. [Description of CGNS mesh format](https://cgns.github.io/WhatIsCGNS.html).  
2. Both single- and multi-block are supported.  
3. CGNS files exported from ANSA and Pointwise are well tested and supported.  


## UGIRD (AFLR3)
1. [Description of UGRID mesh format](https://www.simcenter.msstate.edu/software/documentation/ug_io/3d_grid_file_type_ugrid.html).  
2. Both big- (*.b8.ugrid) and little- (*.lb8.ugrid) endianness are supported. [Description of endianness](https://en.wikipedia.org/wiki/Endianness).  
3. If the endianness is not specified in the mesh filename, then you must select one when uploading the mesh.  

> If you don't know the endianness, we recommend trying little-endian first as it's more common in newer architectures/systems.  

## Flow360Mesh.json
In addition to the mesh file, you also need to provide description of:  
1. No Slip Walls of your mesh.  
2. Sliding Interfaces if there are any in your mesh.  

The data can be provided either manually in the text box, or uploaded as a JSON file. See the format and examples below:

For the UGIRD file, if surfaces 1, 2, and 3 are `noSlipWalls` then the `Flow360Mesh.json` should look like this:
```
{
    "boundaries": {
        "noSlipWalls": [1,2,3]
    }
}
```

For the CGNS file, consider a propeller, enclosed by a sliding interface, located in front of a fuselage, the `Flow360Mesh.json` should look like this:
```
{
    "boundaries": {
        "noSlipWalls": ["rotatingBlock/propeller"]
        "noSlipWalls": ["stationaryBlock/fuselage"]
    },
    "slidingInterfaces": [
        {
            "stationaryPatches": ["stationaryBlock/interface"],
            "rotatingPatches": ["rotatingBlock/interface"],
            "axisOfRotation": [1,0,0],
            "centerOfRotation": [0,0,0]
        }
    ]
}
```
where `rotatingBlock` and `stationaryBlock` are the names you assigned to the blocks,
whereas `propeller`, `fuselage`, and `interface` are the names you assigned to the surfaces in the meshing software.